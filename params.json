{"name":"thread.js","tagline":"The definitive library for real parallel non-blocking thread-based processing in the browser","body":"**thread.js** is lightweight and rich featured library that **simplifies JavaScript parallel computing in browser**\r\nenvironments through a clean and elegant [API](#api) with promise-based asynchronous handling\r\n\r\nIt allows you to run tasks in a non-blocking real thread in a really simple way.\r\nIt also provides built-in support for creating pool of threads to distribute the\r\ntask load across multiple workers transparently using a simple best availability schedule algorithm\r\n\r\nIt uses [Web Workers](http://en.wikipedia.org/wiki/Web_worker) to create real threads,\r\nbut provides fallback support for older browsers based on an `iframe` hack\r\n\r\nWelcome to the multithreading world in the browser, now made simple and funny\r\n\r\nGetting started with [basic usage](#basic-usage),\r\nsome [examples](https://github.com/h2non/thread.js/tree/master/examples) or [tests](https://github.com/h2non/thread.js/tree/master/test) and be aware about [threads limitations](#threads-limitations)\r\n\r\n## Installation\r\n\r\nVia [Bower](http://bower.io)\r\n```bash\r\nbower install thread\r\n```\r\nVia [Component](http://component.io/)\r\n```bash\r\ncomponent install h2non/thread.js\r\n```\r\n\r\nOr loading the script remotely\r\n```html\r\n<script src=\"//cdn.rawgit.com/h2non/thread.js/0.1.1/thread.js\"></script>\r\n```\r\n\r\n### Environments\r\n\r\nCross-browser support guaranteed running tests in [BrowserStack](http://browserstack.com/)\r\n\r\n- Chrome >= 5\r\n- Firefox >= 3\r\n- Safari >= 5\r\n- Opera >= 10\r\n- IE >= 8\r\n\r\n### Basic usage\r\n\r\nIf `require` is available, you must use it to fetch the module.\r\nOtherwise it will be available as global\r\n\r\n```js\r\nvar thread = require('thread')\r\n```\r\n\r\nCreate a new thread with custom scope environment and import external libraries\r\n```js\r\nvar worker = thread({\r\n  env: { numbers: [1,2,3] },\r\n  require: [\r\n    'http://cdnjs.cloudflare.com/ajax/libs/lodash.js/2.4.1/lodash.js'\r\n  ]\r\n})\r\n```\r\n\r\nSynchronous example\r\n```js\r\nvar task = worker.run(function () {\r\n  return _.sortBy(env.numbers, function (num) {\r\n    return Math.sin(num)\r\n  })\r\n})\r\n```\r\n\r\nAsynchronous example\r\n```js\r\nvar task = worker.run(function (done) {\r\n  doAsyncStuff(function () {\r\n    var sorted = _.sortBy(env.numbers, function (num) {\r\n      return Math.sin(num)\r\n    })\r\n    done(null, sorted)\r\n  })\r\n})\r\n```\r\n\r\nConsuming the computed result (promise-based API)\r\n```js\r\ntask.then(function (array) {\r\n  console.log(array) // -> [3, 1, 2]\r\n}).catch(function (err) {\r\n  console.log('Ups:', err.message)\r\n}).finally(function (result) {\r\n  console.log('Final result:', result) // -> [3, 1, 2]\r\n})\r\n```\r\n\r\n## Web Workers resources\r\n\r\n- [Basics](https://developer.mozilla.org/en-US/docs/Web/Guide/Performance/Using_web_workers)\r\n- [HTML5Rocks Tutorial](http://www.html5rocks.com/es/tutorials/workers/basics/)\r\n- [Functions available to workers as global scope](https://developer.mozilla.org/en-US/docs/Web/API/Worker/Functions_and_classes_available_to_workers)\r\n- [Origin policy restrictions](http://www.html5rocks.com/en/tutorials/security/content-security-policy/)\r\n- [Specification](http://www.whatwg.org/specs/web-apps/current-work/multipage/workers.html)\r\n\r\n## Threads limitations\r\n\r\nYou should be aware of some limitations while using threads\r\n\r\nThreads has it's own isolated scope. That means you must explicitly bind values or functions\r\nto the thread in order to consum them.\r\nAny passed value to the thread scope will be cloned (it will be passed by value, not by reference),\r\nso mutation is not possible between scopes\r\n\r\nIf you create a pool of threads, you must consider that threads in the pool are scope-isolated too.\r\nIn other words, it's not supported scope synchronization between threads in the pool.\r\nThat is positive becouse you cannot have side-effects between threads,\r\nbut should be aware about global scope dependencies and mutation in your code in other to avoid inconsistency between threads\r\n\r\nAll values passed to must be JSON-serializable, meaning only primitives types, raw objects and functions.\r\nSame with return values from threads.\r\nDOM nodes, built-in objects or prototypes chains cannot be passed to the thread\r\n\r\nAdditionally, threads do not have access to the DOM API\r\n\r\n## API\r\n\r\n### thread([options])\r\nReturn: `thread` Alias: `thread.create`\r\n\r\nSupported options:\r\n\r\n- **env** `object` Custom environment to bind to the isolated thread scope\r\n- **require** `string|array|object` Source path scripts to load or map of values/functions to bind\r\n- **namespace** `string` Global namespace to allocate the scope environment. Default to `env`\r\n\r\n```js\r\nthread({\r\n  namespace: 'global',\r\n  env: {\r\n    x: 10,\r\n    sqrt: function (n) {\r\n      return Math.sqrt(Math.pow(n, n))\r\n    }\r\n  },\r\n  require: [\r\n    'http://cdn.rawgit.com/h2non/hu/0.1.1/hu.js'\r\n  ]\r\n})\r\n```\r\n\r\n#### thread#run(fn, env, args)\r\nReturn: `task` Alias: `exec`\r\n\r\nRun the given function in the thread isolated scope.\r\nYou can optionally bind a custom context (as `map` of values) or passing function arguments\r\n(as `array`) to be injected when the function will be invoked\r\n\r\nBind values must be serializable types (see [threads limitations](#threads-limitations))\r\n\r\nRun a function and return the result synchronously (`return` statement required)\r\n```js\r\nthread().run(function () {\r\n  return 2 * 2\r\n}).then(function (result) {\r\n  console.log(result) // -> 4\r\n})\r\n```\r\n\r\nBinding a custom context and return the result asynchronously\r\n```js\r\nthread().run(function (done) {\r\n  done(null, this.x * 2)\r\n}, { x: 2 }).then(function (result) {\r\n  console.log(result) // -> 4\r\n})\r\n```\r\n\r\nPassing arguments and return the result asynchronously\r\n```js\r\nthread().run(function (num, done) {\r\n  done(null, num * this.x)\r\n}, { x: 2 }, [ 2 ]).then(function (result) {\r\n  console.log(result) // -> 4\r\n})\r\n```\r\n\r\n#### thread#pool(number)\r\nReturn: `thread`\r\n\r\nCreate a pool of a maximum number of threads and run tasks across them\r\n\r\nIt implements a simple best availability scheudle algorithm to transparently\r\ndistribute tasks across multiple workers.\r\nIt will only create a new thread if it's required and there is not any other thread available\r\n\r\nThis feature is still beta and major improvements will be done in future releases.\r\nAny feedback will be really appreciated\r\n\r\n```js\r\n// create a pool with a maximum of 10 threads\r\nvar pool = thread({ env: { x: 2 } }).pool(10)\r\nvar count = 1\r\nvar tasks = 50\r\n\r\nfunction runAsyncTask(num) {\r\n  setTimeout(function () {\r\n    pool.run(function (done) {\r\n      setTimeout(function () {\r\n        done(null, env.x * 2)\r\n      }, Math.random() * 1000)\r\n    }).then(function (result) {\r\n      console.log('Task:', num, '- Result:', result, '- Used threads:', pool.threadPool.length)\r\n      if (count++ === tasks) {\r\n        console.log('Tasks finished')\r\n        pool.kill() // kill all pool threads\r\n      }\r\n    })\r\n  }, Math.random() * 1000)\r\n}\r\n\r\nfor (var i = 0; i < tasks; i += 1) {\r\n  runAsyncTask(i)\r\n}\r\n```\r\n\r\n#### thread#bind(obj)\r\nReturn: `thread` Alias: `set`\r\n\r\nBind a map of values to the isolated thread scope.\r\nYou can do the same passing an object via `thread#require()`\r\n\r\nPassed values will be exposed in the global namespace (default to `env`)\r\n\r\n```js\r\nvar task = thread().bind({\r\n  num: 4,\r\n  list: [3,2,1],\r\n  defer: function (fn) {\r\n    setTimeout(fn, 1)\r\n  }\r\n})\r\n\r\ntask.run(function (done) {\r\n  env.defer(function () {\r\n    done(null, env.list.reverse().push(env.num))\r\n  })\r\n}).then(function (result) {\r\n  console.log(result) // -> [1,2,3,4]\r\n})\r\n```\r\n\r\n#### thread#require(sources)\r\nReturn: `thread` Alias: `import`\r\n\r\nLoad remote scripts from a valid URL, bind an object or functions to the thread isolated scope.\r\nPassed values will be exposed in the global namespace (default to `env`)\r\n\r\nImporting a remote script\r\n```js\r\nthread()\r\n  .require('http://cdn.rawgit.com/h2non/hu/0.1.1/hu.js')\r\n  .run(function () {\r\n    return typeof hu === 'object'\r\n  }).then(function (exists) {\r\n    console.log(exists) // -> true\r\n  })\r\n```\r\n\r\nOr multiple scripts\r\n```js\r\nthread().require([\r\n  'http://cdn.rawgit.com/h2non/hu/0.1.1/hu.js',\r\n  'http://cdn.rawgit.com/h2non/fw/0.1.2/fw.js'\r\n])\r\n```\r\n\r\nBinding custom objects and primitives types (does the same as `bind()`)\r\n```js\r\nthread().require({\r\n  list: [1,2,3,4,5],\r\n  name: 'John',\r\n  age: 28,\r\n  time: new Date().getTime()\r\n})\r\n```\r\n\r\nBinding functions\r\n```js\r\nthread().require({\r\n  defer: function (fn) {\r\n    setTimeout(fn, 1)\r\n  },\r\n  transform: function (arr) {\r\n    return arr.reverse().filter(function (num) {\r\n      return num > 1 && num < 100\r\n    })\r\n  }\r\n})\r\n```\r\n\r\nBind values will be available in the global namespace object (default to `env`)\r\n\r\n#### thread#flush()\r\nReturn: `thread`\r\n\r\nFlush the thread cached data and scope environment.\r\nIf you flush the data, you will need\r\n\r\n```js\r\nvar worker = thread({ env: { x: 2 } }).flush()\r\nconsole.log(Object.keys(worker.options.env).length) // -> 0\r\n```\r\n\r\n#### thread#flushTasks()\r\nReturn: `thread`\r\n\r\nFlush running tasks promises and clean cached values\r\n\r\n```js\r\nvar worker = thread()\r\nworker.run(doLongTask)\r\nworker.flushTasks()\r\nconsole.log(worker.pending()) // -> 0\r\n```\r\n\r\n#### thread#send(msg)\r\nReturn: `thread`\r\n\r\nSend a message directly to the current thread.\r\nUseful for specific use cases, but it's preferably do not use it directly.\r\nUse the `run()` abstraction instead\r\n\r\nBe aware about passing non-serialize data types such as native JavaScript objects,\r\nDOM nodes, objects with self-references... (see threads [limitations](https://github.com/h2non/thread.js#threads-limitations))\r\n\r\n```js\r\nvar worker = thread()\r\nworker.send({ type: 'msg', data: 'hello world' })\r\n```\r\n\r\n#### thread#kill()\r\nReturn: `thread` Alias: `terminate`\r\n\r\nKill the current thread. All the cached data, scope environment and config options will be flushed,\r\nincluding in worker isolated scope\r\n\r\nIt's recommended you explicit kill any unused thread in order to avoid memory issues in long term computations\r\n\r\n```js\r\nvar worker = thread()\r\nworker.run(longTask).then(function () {\r\n  worker.kill()\r\n})\r\n```\r\n\r\n#### thread#start([options])\r\nReturn: `thread`\r\n\r\nStart (or restart) the current thread.\r\nIf the thread was previously killed, you can reuse it calling this method\r\n\r\n```js\r\nvar options = { env: { x: 2 } }\r\nvar worker = thread(options)\r\nworker.kill() // explicit kill\r\nworker.start(options) // explicit re-start, passing the same options\r\n```\r\n\r\n#### thread#pending()\r\nReturn: `number`\r\n\r\nReturn the pending running tasks on the current thread\r\n\r\n```js\r\nvar worker = thread()\r\nvar task = worker.run(longAsyncTask)\r\nworker.pending() // -> 1\r\ntask.then(function () {\r\n  worker.pending() // -> 0\r\n})\r\n```\r\n\r\n#### thread#running()\r\nReturn: `boolean`\r\n\r\nReturn `true` if the current thread has running tasks\r\n\r\n```js\r\nthread().run(longAsyncTask).running() // -> true\r\nthread().run(tinySyncTask).running() // -> false\r\n```\r\n\r\n#### thread#idle()\r\nReturn: `boolean` Alias: `sleeping`\r\n\r\nReturn `true` if the current thread is in idle state.\r\n\r\nA thread will be considered in idle state if its latest executed task exceeds from the [idleTime](#threadidletime).\r\nBy default, the idle time will be 30 seconds\r\n\r\n```js\r\nvar worker = thread()\r\nworker.idleTime = 1000 // set max 1 second\r\nvar task = worker.run(someTask)\r\nsetTimeout(function () {\r\n  // after idle time exceeds, the thread will be in idle state\r\n  worker.idle() // -> true\r\n}, 2000)\r\n```\r\n\r\n#### thread#terminated\r\nType: `boolean`\r\n\r\nExpose the thread run state\r\n\r\n```js\r\nthread().terminated // -> false\r\nthread().kill().terminated // -> true\r\n```\r\n\r\n#### thread#on(type, handler)\r\nReturn: `thread` Alias: `addEventListener`\r\n\r\nAdd a custom worker event handler. By default you don't need to handle\r\nevents directly, use it only for exceptional specific purposes\r\n\r\nSupported event types are `error` and `message`\r\n\r\n#### thread#off(type, handler)\r\nReturn: `thread` Alias: `removeEventListener`\r\n\r\nRemove a worker event listener.\r\nIt's required to pass the original handler function in order to remove it\r\n\r\n#### thread#maxTaskDelay\r\nType: `number` Default: `0`\r\n\r\nThe maximum amount of time that a task can take in miliseconds.\r\nIf the task computation time exceed, it will be exit as error.\r\n\r\nBy default this feature is disabled in order to avoid unnecessary computations\r\n\r\nThis value will be applied to every task which runs in the current thread or a pool of threads\r\n\r\n```js\r\nvar worker = thread()\r\nworker.maxTaskDelay = 1000\r\nworker.run(function (done) {\r\n  setTimeout(done, 2000)\r\n}).catch(function (err) {\r\n  console.log(err.message) // -> task execution time exceeded\r\n})\r\n```\r\n\r\n#### thread#idleTime\r\nType: `number` Default: `30000`\r\n\r\nThe minimum time in milliseconds that a thread is considered in sleeping (idle) state\r\n\r\n#### thread#isPool\r\nType: `boolean`\r\n\r\nCheck if the current `thread` instance is a pool of threads\r\n\r\n```js\r\nvar pool = thread().pool(2)\r\npool.isPool // -> true\r\n```\r\n\r\n### thread.Task(thread [, env])\r\nReturn: `task`\r\n\r\nCreate a new task in the given thread\r\n\r\nNormally you don't need to call it directly, it will done via `thread.run()` factory\r\n\r\n```js\r\nvar worker = thread({ env: { x: 2 }})\r\nvar task = new thread.Task(worker, { y: 2 })\r\ntask.run(function () {\r\n  return env.x * this.y\r\n}).then(function (result) {\r\n  console.log(result) // -> 4\r\n})\r\n```\r\n\r\n#### Task#then(successFn [, errorFn])\r\nReturn: `task`\r\n\r\nAdd success and error (optionally) result handlers for the current task\r\n\r\n```js\r\nvar worker = thread()\r\nvas task = new thread.Task(worker)\r\ntask.run(longAsyncTask).then(function (result) {\r\n  console.log(result)\r\n})\r\n```\r\n\r\n#### Task#catch(errorFn)\r\nReturn: `task`\r\n\r\nAdd an error handlers for the current task\r\n\r\n```js\r\nvar worker = thread()\r\nvas task = new thread.Task(worker)\r\ntask.run(longAsyncTask).catch(function (err) {\r\n  console.log(err)\r\n})\r\n```\r\n\r\n#### Task#finally(finalFn)\r\nReturn: `task`\r\n\r\nAdd a final handler for the current task.\r\nIt will be ejecuted when the task finished with `success` or `error` state\r\n\r\n```js\r\nvar worker = thread()\r\nvas task = new thread.Task(worker)\r\ntask.run(longAsyncTask).finally(function (result) {\r\n  console.log(result)\r\n})\r\n```\r\n\r\n#### Task#bind(obj)\r\nReturn: `task`\r\n\r\nBind custom map environment to the current task scope\r\n\r\n```js\r\nvar worker = thread()\r\nvas task = new thread.Task(worker)\r\ntask.bind({ x: 2 })\r\ntask.run(function () {\r\n  return this.x * 2\r\n}).then(function (result) {\r\n  console.log(result) // -> 4\r\n})\r\n```\r\n\r\n#### Task#flush()\r\nReturn: `task`\r\n\r\nFlush cached result data and set the initial task state\r\n\r\n```js\r\nvar worker = thread()\r\nvas task = new thread.Task(worker)\r\ntask.flush()\r\ntask.flushed() // -> true\r\n```\r\n\r\n#### Task#flushed()\r\nReturn: `boolean`\r\n\r\nReturn `true` if task data was already flushed\r\n\r\n### Static members\r\n\r\n#### thread.total()\r\nReturn: `number`\r\n\r\nReturn the total number of threads created (running and idle)\r\n\r\n#### thread.all()\r\nReturn: `array`\r\n\r\nReturn an array with all created threads\r\n\r\n#### thread.running()\r\nReturn: `array`\r\n\r\nReturn an `array` of the running threads (are processing one or more tasks)\r\n\r\n#### thread.idle()\r\nReturn: `array`\r\n\r\nReturn an `array` of the idle threads (thread which has no execute tasks for a long time)\r\n\r\n#### thread.killAll()\r\nAlias: `terminateAll`\r\n\r\nKill all the existent threads\r\n\r\n#### thread.flush()\r\n\r\nFlush the built-in threads store manager (but they will not be killed)\r\n\r\n#### thread.VERSION\r\nType: `string`\r\n\r\nCurrent library semantic version\r\n\r\n## Contributing\r\n\r\nWanna help? Cool! It will be appreciated :)\r\n\r\nYou must add new test cases for any new feature or refactor you do,\r\nalways following the same design/code patterns that already exist\r\n\r\n### Development\r\n\r\nOnly [node.js](http://nodejs.org) is required for development\r\n\r\nClone the repository\r\n```bash\r\n$ git clone https://github.com/h2non/thread.js.git && cd thread.js\r\n```\r\n\r\nInstall dependencies\r\n```bash\r\n$ npm install\r\n```\r\n\r\nGenerate browser bundle source\r\n```bash\r\n$ make browser\r\n```\r\n\r\nRun tests\r\n```bash\r\n$ make test\r\n```\r\n\r\nSee the [examples](http://localhost:8080/examples)\r\n```bash\r\n$ ./node_modules/.bin/http-server\r\n```\r\n\r\n## License\r\n\r\n[MIT](http://opensource.org/licenses/MIT) Â© Tomas Aparicio\r\n\r\n[travis]: http://travis-ci.org/h2non/thread.js\r\n[gemnasium]: https://gemnasium.com/h2non/thread.js\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}